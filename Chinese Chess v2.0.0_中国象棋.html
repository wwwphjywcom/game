<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>中国象棋 - 人机对战</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #333;
            cursor: pointer;
        }
        #message {
            margin-top: 10px;
            text-align: center;
            font-size: 18px;
            color: #333;
        }
        .board-container {
            position: relative;
        }
        .coordinates {
            position: absolute;
            font-size: 14px;
            color: #555;
            pointer-events: none;
        }
        .row-coord {
            left: -20px;
            width: 20px;
            text-align: center;
        }
        .col-coord {
            bottom: -20px;
            width: 60px;
            text-align: center;
        }
        .controls {
            margin-top: 10px;
            text-align: center;
        }
        button {
            padding: 8px 15px;
            margin: 0 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        .difficulty {
            margin-top: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="board-container">
        <canvas id="chessBoard" width="600" height="600"></canvas>
        <!-- 坐标标记 -->
        <div class="coordinates col-coord" style="left: 30px">a</div>
        <div class="coordinates col-coord" style="left: 90px">b</div>
        <div class="coordinates col-coord" style="left: 150px">c</div>
        <div class="coordinates col-coord" style="left: 210px">d</div>
        <div class="coordinates col-coord" style="left: 270px">e</div>
        <div class="coordinates col-coord" style="left: 330px">f</div>
        <div class="coordinates col-coord" style="left: 390px">g</div>
        <div class="coordinates col-coord" style="left: 450px">h</div>
        <div class="coordinates col-coord" style="left: 510px">i</div>
        
        <!-- 行坐标标记 -->
        <div class="coordinates row-coord" style="top: 50px">10</div>
        <div class="coordinates row-coord" style="top: 100px">9</div>
        <div class="coordinates row-coord" style="top: 150px">8</div>
        <div class="coordinates row-coord" style="top: 200px">7</div>
        <div class="coordinates row-coord" style="top: 250px">6</div>
        <div class="coordinates row-coord" style="top: 300px">5</div>
        <div class="coordinates row-coord" style="top: 350px">4</div>
        <div class="coordinates row-coord" style="top: 400px">3</div>
        <div class="coordinates row-coord" style="top: 450px">2</div>
        <div class="coordinates row-coord" style="top: 500px">1</div>
    </div>
    <div id="message"></div>
    <div class="controls">
        <button id="restartBtn">重新开始</button>
        <button id="hintBtn">提示</button>
    </div>
    <div class="difficulty">
        <label for="difficulty">难度:</label>
        <select id="difficulty">
            <option value="easy">简单</option>
            <option value="medium" selected>中等</option>
            <option value="hard">困难</option>
        </select>
    </div>

    <script>
        // 棋子数据结构和配置
        const pieces = {
            'K': { name: '帥', value: 10000, color: 'red' },
            'k': { name: '將', value: 10000, color: 'black' },
            'A': { name: '仕', value: 200, color: 'red' },
            'a': { name: '士', value: 200, color: 'black' },
            'B': { name: '相', value: 200, color: 'red' },
            'b': { name: '象', value: 200, color: 'black' },
            'N': { name: '馬', value: 400, color: 'red' },
            'n': { name: '馬', value: 400, color: 'black' },
            'R': { name: '車', value: 900, color: 'red' },
            'r': { name: '車', value: 900, color: 'black' },
            'C': { name: '炮', value: 450, color: 'red' },
            'c': { name: '炮', value: 450, color: 'black' },
            'P': { name: '兵', value: 100, color: 'red' },
            'p': { name: '卒', value: 100, color: 'black' }
        };

        // 游戏状态
        let gameState = {
            board: [
                ['r', 'n', 'b', 'a', 'k', 'a', 'b', 'n', 'r'],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                [' ', 'c', ' ', ' ', ' ', ' ', ' ', 'c', ' '],
                ['p', ' ', 'p', ' ', 'p', ' ', 'p', ' ', 'p'],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                ['P', ' ', 'P', ' ', 'P', ' ', 'P', ' ', 'P'],
                [' ', 'C', ' ', ' ', ' ', ' ', ' ', 'C', ' '],
                [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                ['R', 'N', 'B', 'A', 'K', 'A', 'B', 'N', 'R']
            ],
            currentPlayer: 'red', // 红方先行
            selectedPiece: null,
            gameOver: false,
            winner: null,
            playerColor: 'red', // 玩家颜色，默认为红方
            aiThinking: false
        };

        // 初始化棋盘
        function initChessBoard() {
            const canvas = document.getElementById('chessBoard');
            const ctx = canvas.getContext('2d');
            
            // 绘制棋盘
            drawBoard(ctx);
            drawPieces(ctx);
            
            // 添加事件监听
            canvas.addEventListener('click', handleCanvasClick);
            document.getElementById('message').textContent = '游戏开始，请选择红方棋子';
            
            // 按钮事件
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            document.getElementById('hintBtn').addEventListener('click', showHint);
            document.getElementById('difficulty').addEventListener('change', changeDifficulty);
            
            // 如果玩家选择黑方，AI先行动
            if (gameState.playerColor === 'black') {
                setTimeout(makeAIMove, 500);
            }
        }

        // 重新开始游戏
        function restartGame() {
            gameState = {
                board: [
                    ['r', 'n', 'b', 'a', 'k', 'a', 'b', 'n', 'r'],
                    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                    [' ', 'c', ' ', ' ', ' ', ' ', ' ', 'c', ' '],
                    ['p', ' ', 'p', ' ', 'p', ' ', 'p', ' ', 'p'],
                    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                    ['P', ' ', 'P', ' ', 'P', ' ', 'P', ' ', 'P'],
                    [' ', 'C', ' ', ' ', ' ', ' ', ' ', 'C', ' '],
                    [' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '],
                    ['R', 'N', 'B', 'A', 'K', 'A', 'B', 'N', 'R']
                ],
                currentPlayer: 'red',
                selectedPiece: null,
                gameOver: false,
                winner: null,
                playerColor: gameState.playerColor,
                aiThinking: false
            };
            
            const canvas = document.getElementById('chessBoard');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBoard(ctx);
            drawPieces(ctx);
            
            document.getElementById('message').textContent = gameState.playerColor === 'red' ? '游戏开始，请选择红方棋子' : 'AI正在思考...';
            
            // 如果玩家选择黑方，AI先行动
            if (gameState.playerColor === 'black') {
                setTimeout(makeAIMove, 500);
            }
        }

        // 改变难度
        function changeDifficulty() {
            document.getElementById('message').textContent = `难度已调整为: ${document.getElementById('difficulty').value}`;
        }

        // 绘制棋盘
        function drawBoard(ctx) {
            // 绘制木纹背景
            const gradient = ctx.createLinearGradient(0, 0, 600, 600);
            gradient.addColorStop(0, '#f5deb3');
            gradient.addColorStop(1, '#e6c38b');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 600, 600);

            // 绘制边框
            ctx.lineWidth = 3;
            ctx.strokeRect(45, 45, 510, 510);

            // 列间距
            const columnWidth = 500 / 8;
            
            // 行高
            const rowHeight = 50;
            
            // 绘制横线（共10行）
            for (let i = 0; i < 10; i++) {
                ctx.beginPath();
                
                // 红方顶部线条调整（第1-5行）
                if (i <= 4) {
                    ctx.moveTo(50, 50 + i * rowHeight);
                    ctx.lineTo(550, 50 + i * rowHeight);
                } 
                // 黑方底部线条（第6-10行）
                else {
                    ctx.moveTo(50, 50 + i * rowHeight);
                    ctx.lineTo(550, 50 + i * rowHeight);
                }
                
                ctx.stroke();
            }

            // 绘制竖线（共9列）
            for (let i = 0; i < 9; i++) {
                ctx.beginPath();
                ctx.moveTo(50 + i * columnWidth, 50);
                ctx.lineTo(50 + i * columnWidth, 550);
                ctx.stroke();
            }

            // 绘制楚河汉界
            ctx.fillStyle = "#f5deb3";
            ctx.fillRect(50, 250, 500, 50);
            
            ctx.font = "24px 隶书";
            ctx.fillStyle = "#8B4513";
            ctx.fillText("楚  河", 230, 275);
            ctx.fillText("汉  界", 330, 275);

            // 绘制九宫格斜线
            drawPalaceDiagonals(ctx, columnWidth, rowHeight);
            
            // 绘制兵/卒标记
            drawPawnMarkers(ctx, columnWidth, rowHeight);
        }
        
        // 绘制九宫格斜线
        function drawPalaceDiagonals(ctx, columnWidth, rowHeight) {
            // 黑方九宫格（顶部）
            ctx.beginPath();
            ctx.moveTo(50 + 3 * columnWidth, 50);  // 第4列，第1行
            ctx.lineTo(50 + 5 * columnWidth, 50 + 2 * rowHeight); // 第6列，第3行
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(50 + 5 * columnWidth, 50);  // 第6列，第1行
            ctx.lineTo(50 + 3 * columnWidth, 50 + 2 * rowHeight); // 第4列，第3行
            ctx.stroke();
            
            // 红方九宫格（底部，镜像黑方）
            ctx.beginPath();
            ctx.moveTo(50 + 3 * columnWidth, 50 + 7 * rowHeight);  // 第4列，第8行
            ctx.lineTo(50 + 5 * columnWidth, 50 + 9 * rowHeight); // 第6列，第10行
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(50 + 5 * columnWidth, 50 + 7 * rowHeight);  // 第6列，第8行
            ctx.lineTo(50 + 3 * columnWidth, 50 + 9 * rowHeight); // 第4列，第10行
            ctx.stroke();
        }

        // 绘制兵/卒位置的特殊标记
        function drawPawnMarkers(ctx, columnWidth, rowHeight) {
            const size = 8;
            
            // 黑方卒标记（第4行）
            const blackPawnY = 50 + 3 * rowHeight;
            
            // 红方兵标记（第7行）
            const redPawnY = 50 + 6 * rowHeight;
            
            // 为第0、2、4、6、8列绘制标记
            [0, 2, 4, 6, 8].forEach(col => {
                const x = 50 + col * columnWidth;
                
                // 黑卒标记
                drawMarker(ctx, x, blackPawnY, size, '#000080');
                
                // 红兵标记
                drawMarker(ctx, x, redPawnY, size, '#c11b17');
            });
        }
        
        // 绘制单个兵/卒标记（十字形）
        function drawMarker(ctx, x, y, size, color) {
            ctx.beginPath();
            ctx.moveTo(x - size, y);
            ctx.lineTo(x + size, y);
            ctx.moveTo(x, y - size);
            ctx.lineTo(x, y + size);
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }

        // 绘制棋子
        function drawPieces(ctx) {
            const columnWidth = 500 / 8;
            const rowHeight = 50;
            
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = gameState.board[row][col];
                    if (piece !== ' ') {
                        // 棋子位置
                        const x = 50 + col * columnWidth;
                        const y = 50 + row * rowHeight;
                        
                        // 绘制棋子阴影
                        ctx.beginPath();
                        ctx.arc(x + 2, y + 2, 22, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.fill();
                        
                        // 绘制棋子圆形
                        ctx.beginPath();
                        ctx.arc(x, y, 22, 0, Math.PI * 2);
                        
                        // 红黑棋子使用不同的渐变
                        const pieceInfo = pieces[piece];
                        if (pieceInfo.color === 'red') {
                            const gradient = ctx.createRadialGradient(
                                x - 5, y - 5, 5,
                                x, y, 22
                            );
                            gradient.addColorStop(0, '#ff5e5e');
                            gradient.addColorStop(1, '#c11b17');
                            ctx.fillStyle = gradient;
                        } else {
                            const gradient = ctx.createRadialGradient(
                                x - 5, y - 5, 5,
                                x, y, 22
                            );
                            gradient.addColorStop(0, '#4a4aff');
                            gradient.addColorStop(1, '#000080');
                            ctx.fillStyle = gradient;
                        }
                        ctx.fill();
                        
                        // 绘制棋子边框
                        ctx.beginPath();
                        ctx.arc(x, y, 22, 0, Math.PI * 2);
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = '#fff';
                        ctx.stroke();
                        
                        // 绘制棋子内部文字
                        ctx.fillStyle = '#fff';
                        ctx.font = "20px 微软雅黑";
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(pieceInfo.name, x, y);
                        
                        // 如果是选中的棋子，添加高亮效果
                        if (gameState.selectedPiece && 
                            gameState.selectedPiece.row === row && 
                            gameState.selectedPiece.col === col) {
                            ctx.beginPath();
                            ctx.arc(x, y, 25, 0, Math.PI * 2);
                            ctx.strokeStyle = '#ff0000';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // 如果游戏结束，显示结束信息
            if (gameState.gameOver) {
                drawGameOver(ctx);
            }
        }

        // 绘制游戏结束信息
        function drawGameOver(ctx) {
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            
            // 绘制半透明背景
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, width, height);
            
            // 绘制胜利信息
            ctx.fillStyle = '#fff';
            ctx.font = "36px 微软雅黑";
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${gameState.winner === 'red' ? '红方胜利！' : '黑方胜利！'}`, width / 2, height / 2);
        }

        // 坐标转换
        function toBoardCoord(x, y) {
            const columnWidth = 500 / 8;
            const rowHeight = 50;
            
            // 计算列坐标
            const col = Math.round((x - 50) / columnWidth);
            
            // 计算行坐标
            const row = Math.round((y - 50) / rowHeight);
            
            return { col, row };
        }

        // 检查棋子移动是否合法
        function isValidMove(from, to) {
            const piece = gameState.board[from.row][from.col];
            const target = gameState.board[to.row][to.col];

            // 不能移动到自己的棋子上
            if (target !== ' ' && ((piece === piece.toUpperCase() && target === target.toUpperCase()) || (piece === piece.toLowerCase() && target === target.toLowerCase()))) {
                return false;
            }

            // 检查坐标是否在有效范围内
            if (to.col < 0 || to.col > 8 || to.row < 0 || to.row > 9) {
                return false;
            }

            switch (piece) {
                case 'K':
                case 'k':
                    // 帅/将只能在九宫格内移动，且每次只能移动一格
                    const inPalace = (piece === 'K' && to.row >= 7 && to.row <= 9 && to.col >= 3 && to.col <= 5) || 
                                    (piece === 'k' && to.row >= 0 && to.row <= 2 && to.col >= 3 && to.col <= 5);
                    const isOneStep = Math.abs(to.row - from.row) + Math.abs(to.col - from.col) === 1;
                    
                    // 将帅照面规则
                    if (piece === 'K' && target === 'k' && to.col === from.col) {
                        let count = 0;
                        const startRow = Math.min(from.row, to.row) + 1;
                        const endRow = Math.max(from.row, to.row);
                        for (let i = startRow; i < endRow; i++) {
                            if (gameState.board[i][from.col] !== ' ') count++;
                        }
                        return count === 0;
                    }
                    
                    if (piece === 'k' && target === 'K' && to.col === from.col) {
                        let count = 0;
                        const startRow = Math.min(from.row, to.row) + 1;
                        const endRow = Math.max(from.row, to.row);
                        for (let i = startRow; i < endRow; i++) {
                            if (gameState.board[i][from.col] !== ' ') count++;
                        }
                        return count === 0;
                    }
                    
                    return inPalace && isOneStep;
                case 'A':
                case 'a':
                    // 仕/士只能在九宫格内斜着移动一格
                    const inPalaceA = (piece === 'A' && to.row >= 7 && to.row <= 9 && to.col >= 3 && to.col <= 5) || 
                                     (piece === 'a' && to.row >= 0 && to.row <= 2 && to.col >= 3 && to.col <= 5);
                    const isDiagonalOneStep = Math.abs(to.row - from.row) === 1 && Math.abs(to.col - from.col) === 1;
                    return inPalaceA && isDiagonalOneStep;
                case 'B':
                case 'b':
                    // 相/象不能过河，且走田字，不能被蹩脚
                    if ((piece === 'B' && to.row < 5) || (piece === 'b' && to.row > 4)) return false;
                    const isDiagonalTwoStep = Math.abs(to.row - from.row) === 2 && Math.abs(to.col - from.col) === 2;
                    const blockedX = Math.floor((from.col + to.col) / 2);
                    const blockedY = Math.floor((from.row + to.row) / 2);
                    return isDiagonalTwoStep && gameState.board[blockedY][blockedX] === ' ';
                case 'N':
                case 'n':
                    // 马走日字，不能被蹩脚
                    const dx = Math.abs(to.col - from.col);
                    const dy = Math.abs(to.row - from.row);
                    if ((dx === 2 && dy === 1) || (dx === 1 && dy === 2)) {
                        if (dx === 2) {
                            const blockedX = from.col + (to.col - from.col) / 2;
                            return gameState.board[from.row][blockedX] === ' ';
                        } else {
                            const blockedY = from.row + (to.row - from.row) / 2;
                            return gameState.board[blockedY][from.col] === ' ';
                        }
                    }
                    return false;
                case 'R':
                case 'r':
                    // 车走直线，中间不能有其他棋子
                    if (from.row === to.row) {
                        const start = Math.min(from.col, to.col) + 1;
                        const end = Math.max(from.col, to.col);
                        for (let i = start; i < end; i++) {
                            if (gameState.board[from.row][i] !== ' ') return false;
                        }
                        return true;
                    } else if (from.col === to.col) {
                        const start = Math.min(from.row, to.row) + 1;
                        const end = Math.max(from.row, to.row);
                        for (let i = start; i < end; i++) {
                            if (gameState.board[i][from.col] !== ' ') return false;
                        }
                        return true;
                    }
                    return false;
                case 'C':
                case 'c':
                    // 炮走直线，吃子需要中间隔一个棋子，不吃子中间不能有棋子
                    if (from.row === to.row) {
                        let count = 0;
                        const start = Math.min(from.col, to.col) + 1;
                        const end = Math.max(from.col, to.col);
                        for (let i = start; i < end; i++) {
                            if (gameState.board[from.row][i] !== ' ') count++;
                        }
                        if (target === ' ' && count === 0) return true;
                        if (target !== ' ' && count === 1) return true;
                    } else if (from.col === to.col) {
                        let count = 0;
                        const start = Math.min(from.row, to.row) + 1;
                        const end = Math.max(from.row, to.row);
                        for (let i = start; i < end; i++) {
                            if (gameState.board[i][from.col] !== ' ') count++;
                        }
                        if (target === ' ' && count === 0) return true;
                        if (target !== ' ' && count === 1) return true;
                    }
                    return false;
                case 'P':
                case 'p':
                    // 兵/卒未过河只能向前走一格，过河后可以左右走一格
                    if (piece === 'P') {
                        if (from.row >= 5) {
                            return to.row === from.row - 1 && to.col === from.col;
                        } else {
                            return (to.row === from.row - 1 && to.col === from.col) || 
                                  (to.row === from.row && Math.abs(to.col - from.col) === 1);
                        }
                    } else {
                        if (from.row <= 4) {
                            return to.row === from.row + 1 && to.col === from.col;
                        } else {
                            return (to.row === from.row + 1 && to.col === from.col) || 
                                  (to.row === from.row && Math.abs(to.col - from.col) === 1);
                        }
                    }
                default:
                    return false;
            }
        }

        // 检查游戏是否结束
        function isGameOver() {
            let hasRedKing = false;
            let hasBlackKing = false;
            
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    if (gameState.board[row][col] === 'K') hasRedKing = true;
                    if (gameState.board[row][col] === 'k') hasBlackKing = true;
                }
            }
            
            return !hasRedKing || !hasBlackKing;
        }

        // 评估当前局面
        function evaluateBoard() {
            let score = 0;
            for (let row = 0; row < 10; row++) {
                for (let col = 0; col < 9; col++) {
                    const piece = gameState.board[row][col];
                    if (piece !== ' ') {
                        // 基础价值
                        let pieceValue = pieces[piece].value;
                        
                        // 位置加成（简单的位置评估）
                        if (piece === piece.toUpperCase()) { // 红方
                            // 兵卒过河加成
                            if (piece === 'P' && row < 5) {
                                pieceValue += 50;
                            }
                            
                            // 车在棋盘中央加成
                            if (piece === 'R' && row >= 2 && row <= 7 && col >= 2 && col <= 6) {
                                pieceValue += 30;
                            }
                            
                            // 马在棋盘中央加成
                            if (piece === 'N' && row >= 2 && row <= 7 && col >= 2 && col <= 6) {
                                pieceValue += 20;
                            }
                            
                            // 炮在合适位置加成
                            if (piece === 'C' && (row === 2 || row === 7) && col >= 2 && col <= 6) {
                                pieceValue += 20;
                            }
                        } else { // 黑方
                            // 兵卒过河加成
                            if (piece === 'p' && row > 4) {
                                pieceValue += 50;
                            }
                            
                            // 车在棋盘中央加成
                            if (piece === 'r' && row >= 2 && row <= 7 && col >= 2 && col <= 6) {
                                pieceValue += 30;
                            }
                            
                            // 马在棋盘中央加成
                            if (piece === 'n' && row >= 2 && row <= 7 && col >= 2 && col <= 6) {
                                pieceValue += 20;
                            }
                            
                            // 炮在合适位置加成
                            if (piece === 'c' && (row === 2 || row === 7) && col >= 2 && col <= 6) {
                                pieceValue += 20;
                            }
                        }
                        
                        if (piece === piece.toUpperCase()) {
                            score += pieceValue;
                        } else {
                            score -= pieceValue;
                        }
                    }
                }
            }
            
            // 如果是AI回合，返回对AI有利的分数
            return gameState.currentPlayer === 'black' ? -score : score;
        }

        // 找出最佳落子 - 使用极小极大算法
        function findBestMove(depth = 2) {
            const difficulty = document.getElementById('difficulty').value;
            const maxDepth = difficulty === 'easy' ? 1 : (difficulty === 'medium' ? 2 : 3);
            
            let bestScore = -Infinity;
            let bestMove = null;
            const currentPlayer = gameState.currentPlayer;
            const isMaximizing = currentPlayer === 'black';
            
            // 生成所有可能的移动
            for (let fromRow = 0; fromRow < 10; fromRow++) {
                for (let fromCol = 0; fromCol < 9; fromCol++) {
                    const piece = gameState.board[fromRow][fromCol];
                    if (piece !== ' ' && ((piece === piece.toLowerCase() && currentPlayer === 'black') || (piece === piece.toUpperCase() && currentPlayer === 'red'))) {
                        for (let toRow = 0; toRow < 10; toRow++) {
                            for (let toCol = 0; toCol < 9; toCol++) {
                                const from = { row: fromRow, col: fromCol };
                                const to = { row: toRow, col: toCol };
                                if (isValidMove(from, to)) {
                                    // 模拟移动
                                    const tempBoard = JSON.parse(JSON.stringify(gameState.board));
                                    gameState.board[to.row][to.col] = gameState.board[from.row][from.col];
                                    gameState.board[from.row][from.col] = ' ';
                                    
                                    // 递归评估局面
                                    const score = minimax(depth - 1, -Infinity, Infinity, !isMaximizing);
                                    
                                    // 恢复棋盘
                                    gameState.board = tempBoard;
                                    
                                    // 更新最佳移动
                                    if ((isMaximizing && score > bestScore) || (!isMaximizing && score < bestScore)) {
                                        bestScore = score;
                                        bestMove = { from, to };
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return bestMove;
        }

        // 极小极大算法
        function minimax(depth, alpha, beta, isMaximizingPlayer) {
            if (depth === 0 || isGameOver()) {
                return evaluateBoard();
            }
            
            const currentPlayer = isMaximizingPlayer ? 'black' : 'red';
            
            if (isMaximizingPlayer) {
                let maxScore = -Infinity;
                // 生成所有可能的移动
                for (let fromRow = 0; fromRow < 10; fromRow++) {
                    for (let fromCol = 0; fromCol < 9; fromCol++) {
                        const piece = gameState.board[fromRow][fromCol];
                        if (piece !== ' ' && piece === piece.toLowerCase()) { // 黑方
                            for (let toRow = 0; toRow < 10; toRow++) {
                                for (let toCol = 0; toCol < 9; toCol++) {
                                    const from = { row: fromRow, col: fromCol };
                                    const to = { row: toRow, col: toCol };
                                    if (isValidMove(from, to)) {
                                        // 模拟移动
                                        const tempBoard = JSON.parse(JSON.stringify(gameState.board));
                                        gameState.board[to.row][to.col] = gameState.board[from.row][from.col];
                                        gameState.board[from.row][from.col] = ' ';
                                        
                                        // 递归评估局面
                                        const score = minimax(depth - 1, alpha, beta, false);
                                        
                                        // 恢复棋盘
                                        gameState.board = tempBoard;
                                        
                                        maxScore = Math.max(maxScore, score);
                                        alpha = Math.max(alpha, score);
                                        
                                        // Alpha-beta剪枝
                                        if (beta <= alpha) break;
                                    }
                                }
                                if (beta <= alpha) break;
                            }
                            if (beta <= alpha) break;
                        }
                    }
                    if (beta <= alpha) break;
                }
                return maxScore;
            } else {
                let minScore = Infinity;
                // 生成所有可能的移动
                for (let fromRow = 0; fromRow < 10; fromRow++) {
                    for (let fromCol = 0; fromCol < 9; fromCol++) {
                        const piece = gameState.board[fromRow][fromCol];
                        if (piece !== ' ' && piece === piece.toUpperCase()) { // 红方
                            for (let toRow = 0; toRow < 10; toRow++) {
                                for (let toCol = 0; toCol < 9; toCol++) {
                                    const from = { row: fromRow, col: fromCol };
                                    const to = { row: toRow, col: toCol };
                                    if (isValidMove(from, to)) {
                                        // 模拟移动
                                        const tempBoard = JSON.parse(JSON.stringify(gameState.board));
                                        gameState.board[to.row][to.col] = gameState.board[from.row][from.col];
                                        gameState.board[from.row][from.col] = ' ';
                                        
                                        // 递归评估局面
                                        const score = minimax(depth - 1, alpha, beta, true);
                                        
                                        // 恢复棋盘
                                        gameState.board = tempBoard;
                                        
                                        minScore = Math.min(minScore, score);
                                        beta = Math.min(beta, score);
                                        
                                        // Alpha-beta剪枝
                                        if (beta <= alpha) break;
                                    }
                                }
                                if (beta <= alpha) break;
                            }
                            if (beta <= alpha) break;
                        }
                    }
                    if (beta <= alpha) break;
                }
                return minScore;
            }
        }

        // AI移动
        function makeAIMove() {
            if (gameState.gameOver || gameState.currentPlayer !== 'black' || gameState.aiThinking) return;
            
            gameState.aiThinking = true;
            document.getElementById('message').textContent = 'AI正在思考...';
            
            // 使用setTimeout模拟思考时间
            setTimeout(() => {
                const bestMove = findBestMove();
                
                if (bestMove) {
                    // 执行移动
                    const from = bestMove.from;
                    const to = bestMove.to;
                    
                    gameState.board[to.row][to.col] = gameState.board[from.row][from.col];
                    gameState.board[from.row][from.col] = ' ';
                    
                    // 检查游戏是否结束
                    if (isGameOver()) {
                        gameState.gameOver = true;
                        gameState.winner = gameState.currentPlayer;
                        document.getElementById('message').textContent = '黑方(AI)胜利！';
                    } else {
                        // 切换玩家
                        gameState.currentPlayer = 'red';
                        document.getElementById('message').textContent = '轮到你了，请选择红方棋子';
                    }
                    
                    // 重绘棋盘
                    const canvas = document.getElementById('chessBoard');
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawBoard(ctx);
                    drawPieces(ctx);
                }
                
                gameState.aiThinking = false;
            }, 500);
        }

        // 显示最佳落子提示
        function showHint() {
            if (gameState.gameOver || gameState.currentPlayer !== 'red') return;
            
            const bestMove = findBestMove(1);
            if (bestMove) {
                const canvas = document.getElementById('chessBoard');
                const ctx = canvas.getContext('2d');
                
                const columnWidth = 500 / 8;
                const rowHeight = 50;

                const fromX = 50 + bestMove.from.col * columnWidth;
                const fromY = 50 + bestMove.from.row * rowHeight;
                const toX = 50 + bestMove.to.col * columnWidth;
                const toY = 50 + bestMove.to.row * rowHeight;

                // 高亮最佳落子的起点和终点
                ctx.beginPath();
                ctx.arc(fromX, fromY, 25, 0, Math.PI * 2);
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(toX, toY, 25, 0, Math.PI * 2);
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 显示提示信息
                const pieceInfo = pieces[gameState.board[bestMove.from.row][bestMove.from.col]];
                document.getElementById('message').textContent = `建议移动: ${pieceInfo.name} (${String.fromCharCode(97 + bestMove.from.col)}${10 - bestMove.from.row}) 到 (${String.fromCharCode(97 + bestMove.to.col)}${10 - bestMove.to.row})`;
                
                // 5秒后清除提示
                setTimeout(() => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawBoard(ctx);
                    drawPieces(ctx);
                    document.getElementById('message').textContent = '请选择红方棋子';
                }, 5000);
            }
        }

        // 处理棋盘点击事件
        function handleCanvasClick(e) {
            // 如果是AI回合或者游戏结束，不处理点击
            if (gameState.gameOver || gameState.currentPlayer === 'black' || gameState.aiThinking) return;
            
            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const pos = toBoardCoord(x, y);
            
            // 检查坐标是否在有效范围内
            if (pos.col < 0 || pos.col > 8 || pos.row < 0 || pos.row > 9) return;
            
            const clickedPiece = gameState.board[pos.row][pos.col];
            
            // 如果已经选中了一个棋子，尝试移动
            if (gameState.selectedPiece) {
                const from = gameState.selectedPiece;
                const to = pos;
                
                if (isValidMove(from, to)) {
                    // 执行移动
                    gameState.board[to.row][to.col] = gameState.board[from.row][from.col];
                    gameState.board[from.row][from.col] = ' ';
                    
                    // 检查游戏是否结束
                    if (isGameOver()) {
                        gameState.gameOver = true;
                        gameState.winner = gameState.currentPlayer;
                        document.getElementById('message').textContent = '红方(你)胜利！';
                    } else {
                        // 切换玩家
                        gameState.currentPlayer = 'black';
                        document.getElementById('message').textContent = 'AI正在思考...';
                        
                        // 重绘棋盘
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        drawBoard(ctx);
                        drawPieces(ctx);
                        
                        // AI移动
                        setTimeout(makeAIMove, 500);
                    }
                    
                    // 取消选择
                    gameState.selectedPiece = null;
                } else if (clickedPiece !== ' ' && clickedPiece === clickedPiece.toUpperCase()) {
                    // 如果点击的是另一个红方棋子，更新选择
                    gameState.selectedPiece = pos;
                    document.getElementById('message').textContent = `已选择红方${pieces[clickedPiece].name}`;
                    
                    // 重绘棋盘，高亮选中的棋子
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawBoard(ctx);
                    drawPieces(ctx);
                } else {
                    // 无效移动，取消选择
                    gameState.selectedPiece = null;
                    document.getElementById('message').textContent = '请选择红方棋子';
                    
                    // 重绘棋盘
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawBoard(ctx);
                    drawPieces(ctx);
                }
            } else {
                // 如果没有选中棋子，尝试选择一个
                if (clickedPiece !== ' ' && clickedPiece === clickedPiece.toUpperCase()) {
                    gameState.selectedPiece = pos;
                    document.getElementById('message').textContent = `已选择红方${pieces[clickedPiece].name}`;
                    
                    // 重绘棋盘，高亮选中的棋子
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    drawBoard(ctx);
                    drawPieces(ctx);
                }
            }
        }

        // 初始化游戏
        window.addEventListener('load', initChessBoard);
    </script>
</body>
</html>
    